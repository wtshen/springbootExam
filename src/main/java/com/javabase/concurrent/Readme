synchronized
0.锁的概念:一段synchronized的代码被一个线程执行之前，他要先拿到执行这段代码的权限，
        在Java里边就是拿到某个同步对象的锁（一个对象只有一把锁）；
        如果这个时候同步对象的锁被其他线程拿走了，他（这个线程）就只能等了（线程阻塞在锁池等待队列中）。
        取到锁后，他就开始执行同步代码(被synchronized修饰的代码）；
        线程执行完同步代码后马上就把锁还给同步对象，其他在锁池中等待的某个线程就可以拿到锁执行同步代码了。
        这样就保证了同步代码在统一时刻只有一个线程在执行。
        http://blog.csdn.net/u012291108/article/details/51348603
1.synchronized代码块是原子操作,不可分的,当前线程在执行的时候是不会被打断的.
2.同步和非同步方法是否可以同时调用? 可以的,因为非同步方法不需要检查该对象的锁
3.锁粒度越细越好
4.锁是锁在堆内存的对象上,而不是栈内存对象变量的引用
5.不要以字符串常量作为锁定对象
6.线程间通讯:
    wait notify --必须先加锁,再使用
    ountdownlatch/cyclicbarrier/semaphore
7.ReentrantLock和synchronized的区别
    1.比后者灵活,可进行tryLock,根据返回的锁定状态,实现自己的业务逻辑
    2.synchronized是竞争锁（效率高）,ReentrantLock可以指定公平锁
8.高并发主要3块知识点
    synchronizer 线程间同步,通讯  (1-22)
        synchronized wait notifyall
        Lock ReentrantLock Condition await signalAll
    并发容器
    threadpool\executor\callable\feature